<!--
    (This manual for SQL Beginners is written by
    Faiilj "betternoun" Sagdyiev
    (amycushu for School 21)

    2025-02-20
-->

## Основы SQL_101

### Основные объекты (разделы) в СУБД (SQL)

![Sample](Sample_SQL.png)
>Cхема СУБД

* Для манипуляцией с информацией из БД есть операторы раздела.

  * `DML`
      1. `SELECT` -- выбор инофрации из БД;
      2. `INSERT` -- вставка инофрации из БД;
      3. `UPDATE` -- обновление инофрации из БД;
      4. `DELETE` -- удаление инофрации из БД.


* Для обеспечения безопасности информацим из БД есть операторы раздела.

  * `TCL`
      1. `BEGIN TRANSACTION` -- Начало транзацкии;
      2. `COMMIT` -- Фиксирование результат транзакции/успешного завершения транзакции;
      3. `ROLLBACK` -- Откат изменеией и успешное завершение трнзацкий.


* Для описания таблиц и их изменений

  * `DDL`
      1. `CREATE table` -- Создание таблицы;
      2. `ALTER table` -- Именение таблицы;
      3. `DROP table` -- Удаления(выбрасывание);таблицы;
      4. `CREATE VIEW` -- Создание представления о таблицы;
      5. `ALTER VIEW` -- Изменеие представления о таблице;
      6. `DROP VIEW` -- Удаление представления о таблице.


* Для предоставление доступа к данным

  * `DCL`
      1. `GRANT` -- Предоставление пользователю или группе пользователей доступы(роли) в БД: Таблицы, Функции;
      2. `REVOKE` -- Забор у пользователя или группы пользователей доступы(роли) в БД.

### Типы данных 

`CHAR(n)` и `VARCAHR(n)` предназначены для размещения символов из кодовой страницы.

>`CHAR(n)` имеет строго заданный набор символов.

>`VARCAHR(n)` имеет вариативный набор символо от 0 до n-го количества строк.

Если данные из разных кодовых страниц нужно хранить эти данные в переменных NCHAR(n) и NVARCHAR(n) соответственно.

* Для хранение битовы строк нужно использовать `BIT(n)` -- массив из ровно n bit строк (двоичных разрядов). Для хранения массивов от 0 до n бит массивов нужно использовать `BITVARYING(n)`


* Для хранения целых чисел нужно использовать `INTEGER`, `BIGINT` -- целоечисленное число увеличенной разрядности, `SMALLINT` -- целоечисленное число уменьшенной разрядности.


* Для хранения дат и времён есть типы: `DATE` в формате ГГГГ-ММ-ДД и `TIME` в формате ЧЧ:ММ:СС

### Простая выборка данных

* Структура оператора `SELECT`

1. `SELECT`
    * Список полей и выражений;
    * Перечень полей таблиц, а также выражений;
2. `FROM`
    * Список источриков;
    * Перечень источников данных -- таблиц, представлений, табличных функций;
3. `WHERE`
    * Логическое условие;
    * Условие фильтрации исходных строк;
4. `GROUP BY`
    * Список для группировки;
    * Перечень полей, на основании которых будет выполняться группировка строк талицы;
5. `HAVING`
    * Условие логического условия на вывод данных после GROUP BY;
    * Условие фильтрации сгруппированных строк
6. `ORDER BY`
    * Список полей для сортировки;
    * Перечень полей, по которым будет осуществлена сортировка данных.

>Пример выборки из таблицы


```SQL
    SELECT * FROM name
```

* Звёздочка `*` означает все столбцы, использовать часто не рекомендуется, так как столбцы при отображении могут сместиться и данные из выборки могут быть недействительными. Используйте, если вам нужно предварительно ознакомится с БД.


* Возможно использование скалярных функций, порядок строк в возвращаемом наборе данных не будет определнным, для этого нужно будет использовать логическое условие GROUP BY.


```SQL
SELECT * FROM name
WHERE
```

    * В логчиеском условии `WHERE` могут быть разные операторы к примеру: `<, <=, >, >=, <>, =`
    * В логчиеском условии `WHERE` могут быть логические булевские операторы к примеру: `NOT`, `AND` и `OR`
    * В логчиеском условии `WHERE` может быть оператор `BETWEEN`, что бы проверить перменную в заданных пределах.

* В логчиеском условии WHERE могут быть ключевое слово IN? что бы проверить переменную в заданном диапазоне, которое мы перечисляем непосредственно.


```SQL
SELECT DISTINCT * FROM name
WHERE
```

>Для устранения дублирующих строк есть логическое условие DISTINCT

* Для удобной обратотки строк есть оператор LIKE, проверяющий соотвествие строк по строгому шаблону.


```SQL
SELECT DISTINCT * FROM name 
WHERE name
LIKE
```
* Шаблоны:
    * Шаблон `%` -- любая строка длиной от нуля и более символов;
    * Шаблон `_` -- любой одиночный символ;
    * Шаблоны `[A-Z][a-z]` -- любой одиночный символ, содержашщийся в заданном диапазоне;
    * Шаблоны `[^A-Z][^a-z]` -- любой одиночный символ, не содержашщийся в заданном диапазоне.


```SQL
SELECT DISTINCT * FROM name 
WHERE name
LIKE
ORDER BY ASC or DESC
```

>ORDER BY -- используется для сортировки данных, за ним следует перечень полей или выражений.

### Условные вычисления


```SQL
SELECT name IIF
```

> IIF проверяет логическое условие, которое передаётся ей в качестве первого аргумента, возвращает значение второго аргумента, если логическое истинно, возвращает значение третьего арумента, если логическое выражение ложно.


```SQL
SELECT name CASE
WHEN
THEN 
ELSE 
END AS
```

* Если логических условий несколько есть ключевое слово `CASE`, за которомы следует ключевое слово `WHEN`, которое содержит логическое условие. При выполнение логического условия возвращается ключевое слово `THEN`. Таких связок может быть неогранченное количество раз;
    * При невыполнение условий, возвращается условие указанное после `ELSE`;
    * `CASE` всегда должен быть завершен `END`. Такую схему рекомендуется назвать ярылком `AS`.

### Обработка значений NULL

* Для провреки значения `NULL` необходимо использовать ключевое слово `IS`. Для провреки значения на несоответсвие `NULL` можно исполльзовать конструкции `IS NOT NULL` или `NOT IS NULL`.
    * Для замены значений нужно использовать функцию `ISNULL`, которая проверяет на соотвествие значению `NULL`. 
    * Если первый аргумент не является `NULL`, то он возвращается в качестве результата запроса. Иначне возвращается второй аргумент запроса.

### Агрегатные функции


```SQL
COUNT -- вычитывает кол-во записей в нашей таблице или в вашем запросе
COUNT * -- вычитывает кол-во записей в нашей таблице или в вашем запросе, даже если есть значения NULL
```

* Для суммирования всех чисел нужно использовать SUM. Будет возвращено сумма значейний (NULL не учитывается);	
    * Для вычисления среднего арефмитического нужно использовать AVG. Будет возвращено среднее значение (NULL не учитывается).
    * Для вычисления максимального и минимального значения нужно использовать MAX и MIN соотвественно.

### Выборка из несколькиз таблиц

* Для выборки значений из нескольких таблиц нужно использовать:


```SQL
SELECT name, id
FROM t_person, t_id
```

>Таблицы указываем через запятую

* При перчесление таблиц, в которых есть одноимённые столбцы будет возникать конфликт именований, сервер не сможет определить какое поле нужно вывести. В этом случае нужно использовать полностью квалифицированное имя.


```SQL
SELECT name, id
FROM t_person.name, t_id
```

> Имя таблицы, имя поля

* Для упрощения выборки можно спользовать синонимы при помощи `AS`:


```SQL
SELECT P.name, id
FROM t_person AS P, t_id AS ID
```

### Декартово произведения


```SQL
SELECT * FROM T1, T2
```

> Результат такого запроса будет равно по теории декартово произведения. Проще говоря, сервером будет сделано линейное уравнение 200*500=100,000 <- количество строк и столбцов в вашем новом запросе.

* Данную операцию можно выполнить с помощью `CROSS JOIN`.

### JOIN

* Для выбоора некоторых данныз из таблицы Т2, которые соответствую данным из таблицы Т1, это условие заносится после ключевого слова `ON`. Это объединение называется `INNER JOIN`. 


```SQL
SELECT * FROM T1
INNER JOIN T2 on T1.A = T2.B
```

![innerJoin]()
>Наглядный пример

* Для более мягкого объединения можно использовать `OUTER JOIN` с добавкой `LEFT`, которая говорит нам о присваении значений с левой стороны. Эту нужно, если часть данных в обеих таблицах совпадают.


```SQL
SELECT * FROM T1
LEFT OUTER JOIN T2 on T1.A = T2.B
```

![outerJoin]()
>Наглядный пример

* Тот же самый варинат возможен, если сравниваем таблицы из первой к второй. Этот вариант использвуют реже, но всё же он имеет место быть.


```SQL
SELECT * FROM T1
RIGHT OUTER JOIN T2 on T1.A = T2.B
```

![rightOuterJoin]()
>Наглядный пример

* Для полного объединения таблиц нужно использовать `FULL JOIN`. Сначала идёт поиск совподающих строк и их вывод, после вывод всех строк где есть не соответствия по всем таблицам. Дублирующие строки удаляются приминяется автоматически `DISTINCT`.


```SQL
SELECT * FROM T1
FULL JOIN T2 on T1.A = T2.B
```

![fullJoin]()
>Наглядный пример

### Подзапросы

* Подзапрос это тот же самый запрос, который возвращет скаляр (величину) или таблицу (набор величин). В котором можно использовать в основном запросе в качестве аргумента сравнения.

```SQL
SELECT name, price
FROM menu
WHERE price = 
(
SELECT MIN (price)
FROM menu
WHERE price > 0
)
```

* При возвращении набора величин, обычно это таблицы из одной колонки, то можно использовать на сравнении по принципу вхождения или не вхождения при поомщи ключевого слова `IN` или `NOT IN`
    * Подзапросы могут быть переименованы при помощи `AS`, иногда подхапросы нужно переименовывать обязательно. На примере когда запрос как источник при помощи `FROM`.

```SQL
SELECT P.* FROM
(
SELECT name, price
FROM menu
WHERE price = '*'
) AS A
```

### Операции множеств

```SQL
SELECT name
FROM menu
UNION
SELECT order
FROM p.order WHERE
order IS NOT NULL
ORDER BY name
```

* Для объдинения таблиц нужно использовать `UNION` при этом нужо наложить определённые операции с `SELECT`. Такие таблицы должны быть совместимыми: иметь одинаковое количество столбцов и их строки должны быть совместимого типа. При этом дублирующейся строки удаляются, приминяется подобие `DISTICT`
    * При необходимстои все дубликаты строк можно сохранить при использовании `UNION ALL`, в данном случае подобия `DISTICT` не будет использован.


```SQL
SELECT name
FROM menu
UNION
SELECT order
FROM p.order WHERE
order IS NOT NULL
ORDER BY name
```

* Для объединения двух таблиц с совподающеми значениями нужно использовать `INTERSECT`. При этом именования столбцов не обязательно должно совпадать.


```SQL
SELECT p.name
FROM Order
WHERE p.id = 1
INTERSECT
SELECT p.name
FROM Order
WHERE p.id = 2
```

![inersect]()
>Пример

* Для вычитания таблиц нужно использовать EXCEPT. Можно построить таблицу, в которой строки есть только из одной, а вдругой отсуствуют. При этом важно собд.юдать порядок таблиц. Данные в таблицах должны быть совместимыми.


```SQL
SELECT p.name
FROM Order
WHERE p.id = 1
EXCEPT
SELECT p.name
FROM Order
WHERE p.id = 2
```

!intersect
>Пример

### Обработка данных

* Структура оператора `INSERT`

1. `INSERT`
    * Добавление данных в таблицу;
    * Перечень полей таблиц, а также выражений;
2. `INTO`
    * Таблица назначения;
3. `VALUES`
    * Данные для добавления;
    * Могут быть как константами, так и простыми сущностями;

* При вставке осуществляется проверка на коррекность данных.
    1. Наличие заполненых полей;
    2. Проврека первичного ключа, индецифирующего записи в таблице;
    3. Дополнительная проврека на контроль данных на тригеры или внешние ключи.


```SQL
INSERT INTO ... ...
VALUES ...
```

* Второй вариант использования `INSERT` c помощью `FROM`. 


```SQL
INSERT INTO ... ....
SELECT ... FROM ...
WHERE ... = '...'
```

* Для измеенний данных в таблице нужно использовать `UPDATE`. В дефолтном запросе такой запрос изменяет данные во всей таблице, для выбора области в таблице нужно использовать WHERE, в дополнении можно добавить AND для использования значения, которая уже есть в это колонке.
    * C использованием `FROM` будет сформирован подзапрос, который формирует необходимый набор данных нужный для имзенения таблицы. В этом сулчае нужно быть аккуратным, для каждой строки таблицы нужно сформировать одно скалярное значения, в проивном случае запрос будет неопределён, потому что сервер не сможет выбрать конкертное значение для изменения.


```SQL
UPDATE menu
SET price = price + 100
WHERE pizza_name = 'cheese pizza'
AND pizzeria_id = 4
```

> Наглядный пример

```SQL
UPDATE ...
SET ... AS ....
FROM ... AS ...
INNER JOIN ... AS ...
ON .... = ....
```

* Для удаления данных из таблицы нужно использовать `WHERE` всегда только с `FROM`, в ином случае будет ощичена вся таблица от данных. Такой неверный запрос будет индентичен оператору `TRUNCATE TABLE`, который будет быстрее.
    * Условие ``WHERE`` может быть задано непосредственно, так и с условием подзапроса как на примере. С таким подходом мы ормируем перечень инденфикаторов или иных свойств, которые нужно удалить.

```SQL
DELETE FROM menu
WHERE 'cheese pizza' NOT IN
(
SELECT 'DoDo Pizza' FROM pizzeria
)
```

* Для более сложной модификации данных, где нужно внести изменения во многие таблицы нужно использовать `TRANSACTION`, и заканчимается двуями операторами `COMMIT` или `ROLLBACK`. `COMMIT` для внесений изменений в БД, `ROLLBACK` для отката БД до внесейний изменений.


```SQL
BEGIN TRANSACTION
DELETE FROM pizzeria
WHERE NOT EXISTS
(
SELECT 1 FROM menu
WHERE pizzeria = pizza_name.menu 
)
COMMIT TRANSACTION
```
>Наглядный пример

### Итог

* Cпасибо за прочтения данного гайда, надеюсь он вам поможет при обучении! Я лишь упомянул базовые вещи, которые нужны при изучении материала. Более продвинутые запросы, а также диалекты разных моделей SQL: Oracle, MySQL, MSSQL вы можете изучить самостоятельно. 
* Для связи можно написать в **Телеграм: t.me/betternoun +3 MSK**.
